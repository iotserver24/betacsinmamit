rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check for admin
    function isAdmin() {
      return request.auth != null &&
        exists(/databases/$(database)/documents/admins/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/admins/$(request.auth.uid)).data.role == "admin";
    }
    
    // Check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Validate string field length
    function isValidStringLength(field, minLen, maxLen) {
      return field is string && 
             field.size() >= minLen && 
             field.size() <= maxLen;
    }
    
    // Validate URL field (for GitHub, LinkedIn, etc.)
    function isValidURL(field, maxLen) {
      return field is string && 
             field.size() <= maxLen &&
             (field.matches('https?://.*') || field.matches('[a-zA-Z0-9._-]+'));
    }
    
    // Validate email format (basic check)
    function isValidEmail(email) {
      return email is string && 
             email.matches('.*@.*\\..*') && 
             email.size() <= 254;
    }
    
    // Validate phone number (basic check)
    function isValidPhone(phone) {
      return phone is string && 
             phone.matches('[0-9+\\-\\s()]+') && 
             phone.size() >= 8 && 
             phone.size() <= 20;
    }
    
    // Validate USN format (adjust pattern as needed)
    function isValidUSN(usn) {
      return usn is string && 
             usn.matches('[0-9A-Za-z]+') && 
             usn.size() >= 3 && 
             usn.size() <= 25;
    }
    
    // Check if only allowed fields are being updated
    function onlyUpdatingFields(allowedFields) {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedFields);
    }
    
    // Rate limiting helper (basic implementation)
    function isWithinRateLimit() {
      // This is a basic check - for production, consider using external rate limiting
      return request.time > resource.data.get('lastUpdated', timestamp.value(0)) + duration.value(1, 's');
    }
    
    // ============================================================================
    // USER PROFILES
    // ============================================================================
    
    match /registrations/{userId} {
      allow create: if request.auth != null && request.auth.uid == userId;
      allow read, update, delete: if request.auth != null && request.auth.uid == userId;
    }
    
    match /users/{userId} {
      // Allow public read for core members (team page display)
      // Otherwise, only owners and admins can read
      allow read: if resource.data.role == 'coreMember' || 
                     resource.data.isCoreMember == true ||
                     isOwner(userId) || 
                     isAdmin();
      // Allow an authenticated user to create their own user doc;
      // keep validation path too for compatibility
      allow create: if (isAuthenticated() && request.auth.uid == userId) ||
                     (isAuthenticated() && isValidUserData(request.resource.data));
      allow update: if isAuthenticated() && (isOwner(userId) || isAdmin()) && (
        isValidUserUpdate(request.resource.data, resource.data) ||
        isRelaxedUserProfileUpdate(request.resource.data, resource.data)
      );
      allow delete: if isAuthenticated() && (isOwner(userId) || isAdmin());
      
      // Temporary: More permissive rule for debugging - uncomment to test
      // allow update: if isAuthenticated();

      // Validate user data structure and content
      function isValidUserData(data) {
        return (data.uid == null || data.uid is string) &&
               (data.name == null || data.name == "" || isValidStringLength(data.name, 1, 100)) &&
               (data.email == null || data.email == "" || isValidEmail(data.email)) &&
               (data.photoURL == null || data.photoURL == "" || isValidStringLength(data.photoURL, 0, 500)) &&
               (data.bio == null || data.bio == "" || isValidStringLength(data.bio, 0, 500)) &&
               (data.branch == null || data.branch == "" || isValidStringLength(data.branch, 0, 100)) &&
               (data.usn == null || data.usn == "" || isValidUSN(data.usn)) &&
               (data.github == null || data.github == "" || isValidURL(data.github, 200)) &&
               (data.linkedin == null || data.linkedin == "" || isValidURL(data.linkedin, 200)) &&
               (data.phone == null || data.phone == "" || isValidPhone(data.phone)) &&
               (data.role == null || data.role in ['member', 'coreMember', 'admin', 'User', 'EXECUTIVE MEMBER', 'core']) &&
               (data.roleDetails == null || isValidRoleDetails(data.roleDetails)) &&
               (data.isCoreMember == null || data.isCoreMember is bool) &&
               (data.joinedAt == null || data.joinedAt is timestamp) &&
               (data.membership == null || isValidMembershipData(data.membership)) &&
               (data.certificates == null || data.certificates is list) &&
               (data.profile == null || isValidProfileData(data.profile)) &&
               (data.year == null || data.year == "" || data.year is number) &&
               (data.createdAt == null || data.createdAt is timestamp) &&
               (data.updatedAt == null || data.updatedAt is timestamp);
      }
      
      function isValidRoleDetails(roleDetails) {
        return roleDetails.keys().hasOnly(['position', 'permissions', 'level', 'isNMAMIT']) &&
               isValidStringLength(roleDetails.position, 1, 100) &&
               (roleDetails.permissions == null || roleDetails.permissions is list) &&
               (roleDetails.level == null || isValidStringLength(roleDetails.level, 1, 50)) &&
               (roleDetails.isNMAMIT == null || roleDetails.isNMAMIT is bool);
      }
      
      function isValidMembershipData(membership) {
        return membership.keys().hasOnly(['status', 'type', 'expiresAt', 'startDate']) &&
               (membership.status == null || membership.status in ['active', 'inactive', 'expired', 'suspended']) &&
               (membership.type == null || membership.type in ['core', 'member', 'premium', 'basic', 'one-year', 'two-year', 'three-year']) &&
               (membership.expiresAt == null || membership.expiresAt is timestamp) &&
               (membership.startDate == null || membership.startDate is timestamp);
      }
      
      function isValidProfileData(profile) {
        // Support nested profile fields used by core-profile UI
        return (profile.phone == null || profile.phone == "" || isValidPhone(profile.phone)) &&
               (profile.college == null || profile.college == "" || isValidStringLength(profile.college, 0, 100)) &&
               (profile.branch == null || profile.branch == "" || isValidStringLength(profile.branch, 0, 100)) &&
               (profile.year == null || profile.year == "" || isValidStringLength(profile.year, 0, 20)) &&
               (profile.bio == null || profile.bio == "" || isValidStringLength(profile.bio, 0, 500)) &&
               (profile.usn == null || profile.usn == "" || isValidUSN(profile.usn)) &&
               (profile.linkedin == null || profile.linkedin == "" || isValidURL(profile.linkedin, 200)) &&
               (profile.github == null || profile.github == "" || isValidURL(profile.github, 200)) &&
               (profile.skills == null || profile.skills is list) &&
               // image history is appended when uploading photos
               (profile.imageHistory == null || profile.imageHistory is list);
      }
      
      function isValidUserUpdate(newData, oldData) {
        return isValidUserData(newData) &&
               // createdAt must not change; allow omitting it in updates
               (!(newData.keys().hasAny(['createdAt'])) || newData.createdAt == oldData.createdAt);
      }

      // Allow common profile edits without requiring the entire user schema
      function isRelaxedUserProfileUpdate(newData, oldData) {
        // Only these fields can be updated in relaxed path
        return newData.diff(oldData).affectedKeys().hasOnly([
                'name','bio','branch','usn','github','linkedin','phone','year',
                'profile','updatedAt','photoURL','certificates','email','roleDetails'
               ]) &&
               // Keep createdAt immutable
               (!(newData.keys().hasAny(['createdAt'])) || newData.createdAt == oldData.createdAt);
      }
    }
    
    // ============================================================================
    // CORE TEAM MEMBERS
    // ============================================================================
    
    match /core/{document=**} {
      // Public read access for displaying team
      allow read: if true;
      
      // Only admins can write core team data
      allow write: if isAdmin() && isValidCoreTeamData(request.resource.data);
      
      function isValidCoreTeamData(data) {
        return data.keys().hasOnly(['name', 'position', 'bio', 'image', 'github', 'linkedin', 'email', 'order', 'active', 'year', 'createdAt', 'updatedAt']) &&
               isValidStringLength(data.name, 1, 100) &&
               isValidStringLength(data.position, 1, 100) &&
               (data.bio == null || isValidStringLength(data.bio, 0, 1000)) &&
               (data.image == null || isValidStringLength(data.image, 0, 500)) &&
               (data.github == null || isValidStringLength(data.github, 0, 200)) &&
               (data.linkedin == null || isValidStringLength(data.linkedin, 0, 200)) &&
               (data.email == null || isValidEmail(data.email)) &&
               (data.order == null || data.order is number) &&
               (data.active == null || data.active is bool) &&
               (data.year == null || data.year is number);
      }
    }
    
    // ============================================================================
    // TEAM MEMBERS
    // ============================================================================
    
    match /team-members/{document=**} {
      // Public read access for displaying team
      allow read: if true;
      
      // Authenticated users can create team member entries (for applications)
      allow create: if isAuthenticated() && isValidTeamMemberData(request.resource.data);
      
      // Only admins can update/delete team member data
      allow update, delete: if isAdmin();
      
      function isValidTeamMemberData(data) {
        return data.keys().hasOnly(['name', 'position', 'bio', 'image', 'github', 'linkedin', 'email', 'usn', 'branch', 'year', 'active', 'approved', 'createdAt', 'updatedAt']) &&
               isValidStringLength(data.name, 1, 100) &&
               (data.position == null || isValidStringLength(data.position, 0, 100)) &&
               (data.bio == null || isValidStringLength(data.bio, 0, 500)) &&
               (data.image == null || isValidStringLength(data.image, 0, 500)) &&
               (data.github == null || isValidStringLength(data.github, 0, 200)) &&
               (data.linkedin == null || isValidStringLength(data.linkedin, 0, 200)) &&
               (data.email == null || isValidEmail(data.email)) &&
               (data.usn == null || isValidUSN(data.usn)) &&
               (data.branch == null || isValidStringLength(data.branch, 0, 100)) &&
               (data.year == null || data.year is number) &&
               (data.active == null || data.active is bool) &&
               (data.approved == null || data.approved is bool);
      }
    }
    
    // ============================================================================
    // EVENTS
    // ============================================================================
    
    match /events/{eventId} {
      // Public read access for displaying events
      allow read: if true;

      // CREATE: admins only (public creates happen in eventRegistrations/teams)
      allow create: if isAdmin() && isValidEventData(request.resource.data);

      // UPDATE: admins or limited public updates during registration
      allow update: if (
        isAdmin() && isValidEventUpdate(request.resource.data, resource.data)
      ) || (
        isAuthenticated() && isValidPublicEventRegistrationUpdate(request.resource.data, resource.data)
      );

      // DELETE: admins only
      allow delete: if isAdmin();

      function isValidEventData(data) {
        return data.keys().hasOnly([
          'title','description','brief','image','cloudinaryUrl','originalImagePath',
          'date','time','venue','category','type','entryFee','organizers',
          'contactPersons','year','published','registrationsAvailable',
          'participants','participantCount','searchTitle','searchDescription',
          'status','featured','createdAt','updatedAt','allowViewOtherTeams','teamSizeOptions'
        ]) &&
          isValidStringLength(data.title, 1, 200) &&
          isValidStringLength(data.description, 1, 5000) &&
          (data.brief == null || isValidStringLength(data.brief, 0, 1000)) &&
          (data.image == null || isValidStringLength(data.image, 0, 1000)) &&
          (data.cloudinaryUrl == null || isValidStringLength(data.cloudinaryUrl, 0, 1000)) &&
          (data.venue == null || isValidStringLength(data.venue, 0, 200)) &&
          (data.category == null || data.category in ['PREVIOUS','UPCOMING','CURRENT','ONGOING']) &&
          (data.type == null || data.type in ['SOLO','TEAM','INDIVIDUAL','WORKSHOP','SEMINAR','COMPETITION','BOOTCAMP']) &&
          (data.entryFee == null || data.entryFee is number) &&
          (data.year == null || data.year is number) &&
          (data.published == null || data.published is bool) &&
          (data.registrationsAvailable == null || data.registrationsAvailable is bool) &&
          (data.participants == null || data.participants is list) &&
          (data.participantCount == null || data.participantCount is number) &&
          (data.featured == null || data.featured is bool) &&
          // optional flags
          (data.allowViewOtherTeams == null || data.allowViewOtherTeams is bool) &&
          (data.teamSizeOptions == null || (
            data.teamSizeOptions is list &&
            data.teamSizeOptions.size() >= 1 &&
            data.teamSizeOptions.size() <= 10
          )) &&
          (data.status == null || data.status in ['active','completed','cancelled','postponed']) &&
          (data.organizers == null || isValidStringLength(data.organizers, 0, 200)) &&
          (data.contactPersons == null || data.contactPersons is list) &&
          (data.searchTitle == null || data.searchTitle is string) &&
          (data.searchDescription == null || data.searchDescription is string);
      }

      // Partial update validator: only allowed keys and createdAt must not change
      function isValidEventUpdate(newData, oldData) {
        return newData.diff(oldData).affectedKeys().hasOnly([
          'title','description','brief','image','cloudinaryUrl','originalImagePath',
          'date','time','venue','category','type','entryFee','organizers',
          'contactPersons','year','published','registrationsAvailable',
          'participants','participantCount','searchTitle','searchDescription',
          'status','featured','updatedAt','allowViewOtherTeams','teamSizeOptions'
        ]) &&
          newData.createdAt == oldData.createdAt;
      }

      // Allow signed-in users to only increase participants/participantCount during registration
      function isValidPublicEventRegistrationUpdate(newData, oldData) {
        return newData.diff(oldData).affectedKeys().hasOnly([
                 'participants', 'participantCount', 'updatedAt'
               ]) &&
               // keep creation time immutable (no need to send it in request)
               newData.get('createdAt', oldData.createdAt) == oldData.createdAt &&
               // participantCount can only increase and must be a number
               (newData.participantCount is number) &&
               newData.participantCount >= oldData.participantCount &&
               // allow transforms (arrayUnion) on participants; no type/size checks
               // accept a timestamp without requiring exact equality to request.time
               newData.updatedAt is timestamp;
      }
    }
    
    // ============================================================================
    // TEAMS (User-created teams for events)
    // ============================================================================
    
    match /teams/{teamId} {
      // Authenticated users can read teams they're part of or created; admins can read all
      allow read: if isAuthenticated() && (
        isAdmin() ||
        resource.data.custid == request.auth.uid || 
        request.auth.uid in resource.data.get('members', [])
      );
      
      // Authenticated users can create teams
      allow create: if isAuthenticated() && 
        isValidTeamData(request.resource.data) &&
        request.resource.data.custid == request.auth.uid &&
        // Accept any timestamp value (including serverTimestamp) without requiring exact equality
        request.resource.data.createdAt is timestamp &&
        request.resource.data.updatedAt is timestamp;
      
      // Team owners (or admins) can update teams
      allow update: if isAuthenticated() && 
        (resource.data.custid == request.auth.uid || isAdmin()) &&
        isValidTeamUpdate(request.resource.data, resource.data) &&
        // Accept any timestamp value for updatedAt
        request.resource.data.updatedAt is timestamp &&
        isWithinRateLimit();
      
      // Only team owners or admins can delete teams
      allow delete: if isAuthenticated() && 
        (resource.data.custid == request.auth.uid || isAdmin());
      
      function isValidTeamData(data) {
        return data.keys().hasOnly(['name', 'description', 'custid', 'members', 'maxMembers', 'eventId', 'status', 'createdAt', 'updatedAt']) &&
               isValidStringLength(data.name, 1, 100) &&
               (data.description == null || isValidStringLength(data.description, 0, 500)) &&
               data.custid is string &&
               (data.members == null || (data.members is list && data.members.size() <= 10)) &&
               (data.maxMembers == null || (data.maxMembers is number && data.maxMembers >= 1 && data.maxMembers <= 10)) &&
               (data.eventId == null || data.eventId is string) &&
               (data.status == null || data.status in ['active', 'inactive', 'full']);
      }
      
      function isValidTeamUpdate(newData, oldData) {
        return isValidTeamData(newData) &&
               newData.custid == oldData.custid && // Prevent changing team owner
               newData.createdAt == oldData.createdAt && // Prevent changing creation time
               onlyUpdatingFields(['name', 'description', 'members', 'maxMembers', 'eventId', 'status', 'updatedAt']);
      }
    }

    // ============================================================================
    // EVENT REGISTRATIONS (per-user registrations/teams per event)
    // ============================================================================
    match /eventRegistrations/{regId} {
      // Read: owner or admin; allow backward-compat teamCode reads
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin() ||
        (resource.data.teamCode is string)
      );

      // Create: owner-only with schema validation
      allow create: if isAuthenticated() && isValidEventRegistrationCreate(request.resource.data);

      // Update: owner or admin; only 'members' changes allowed
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || isAdmin()
      ) && isValidEventRegistrationUpdate(request.resource.data, resource.data);

      // No client-side deletes
      allow delete: if false;

      function isValidEventRegistrationCreate(data) {
        // Allow extra descriptive fields used by UI
        return data.keys().hasAny(['registrationType']) &&
               // required base fields
               data.eventId is string &&
               data.userId == request.auth.uid &&
               data.registrationType in ['individual','team'] &&
               // accept any server-applied timestamp without requiring exact equality to request.time
               (data.registeredAt is timestamp) &&
               // optional descriptive fields
               (data.eventTitle == null || data.eventTitle == "" || isValidStringLength(data.eventTitle, 0, 200)) &&
               (data.userName == null || data.userName == "" || isValidStringLength(data.userName, 0, 100)) &&
               (data.userEmail == null || data.userEmail == "" || isValidEmail(data.userEmail)) &&
               (data.status == null || data.status in ['pending','confirmed','cancelled']);
      }

      function isValidEventRegistrationUpdate(newData, oldData) {
        // Allow only 'members' to change; support arrayUnion transforms (no type/size checks)
        return newData.diff(oldData).affectedKeys().hasOnly(['members']) &&
               newData.get('eventId', oldData.eventId) == oldData.eventId &&
               newData.get('registrationType', oldData.registrationType) == oldData.registrationType &&
               newData.get('teamCode', oldData.teamCode) == oldData.teamCode &&
               newData.get('userId', oldData.userId) == oldData.userId;
      }
    }
    
    // ============================================================================
    // RECRUITS (Membership applications)
    // ============================================================================
    
    match /recruits/{document=**} {
      // Authenticated users can read recruit data
      allow read: if isAuthenticated();
      
      // Authenticated users can create recruit applications
      allow create: if isAuthenticated() && isValidRecruitData(request.resource.data);
      
      // Only admins can update recruit data (for processing applications)
      allow update: if isAdmin() && 
        isValidRecruitUpdate(request.resource.data, resource.data);
      
      // Authenticated users can delete recruit data
      allow delete: if isAuthenticated();
      
      function isValidRecruitData(data) {
        return data.keys().hasOnly(['name', 'dateOfBirth', 'usn', 'yearOfStudy', 'branch', 'mobileNumber', 'personalEmail', 'collegeEmail', 'membershipPlan', 'csiIdea', 'paymentStatus', 'paymentId', 'orderId', 'createdAt', 'updatedAt']) &&
               isValidStringLength(data.name, 1, 100) &&
               data.dateOfBirth is timestamp &&
               isValidUSN(data.usn) &&
               isValidStringLength(data.yearOfStudy, 1, 20) &&
               isValidStringLength(data.branch, 1, 100) &&
               isValidPhone(data.mobileNumber) &&
               isValidEmail(data.personalEmail) &&
               (data.collegeEmail == null || isValidEmail(data.collegeEmail)) &&
               isValidStringLength(data.membershipPlan, 1, 50) &&
               isValidStringLength(data.csiIdea, 1, 2000) &&
               (data.paymentStatus == null || data.paymentStatus in ['pending', 'completed', 'failed']) &&
               (data.paymentId == null || isValidStringLength(data.paymentId, 0, 100)) &&
               (data.orderId == null || isValidStringLength(data.orderId, 0, 100)) &&
               (data.createdAt == null || data.createdAt is timestamp) &&
               (data.updatedAt == null || data.updatedAt is timestamp);
      }
      
      function isValidRecruitUpdate(newData, oldData) {
        return isValidRecruitData(newData) &&
               newData.createdAt == oldData.createdAt && // Prevent changing creation time
               // Allow updating payment status and processing fields
               onlyUpdatingFields(['paymentStatus', 'paymentId', 'orderId', 'updatedAt']);
      }
    }
    
    // ============================================================================
    // METADATA (System information)
    // ============================================================================
    
    match /metadata/{document=**} {
      // Public read access for system information
      allow read: if true;
      
      // Only admins can write metadata
      allow write: if isAdmin();
    }
    
    // ============================================================================
    // GENERAL COLLECTIONS
    // ============================================================================
    
    match /admin/{document=**} {
      // Only admins can access admin collections
      allow read, write: if isAdmin();
    }
    
    match /logs/{document=**} {
      // Only admins can access logs
      allow read, write: if isAdmin();
    }
    
    match /analytics/{document=**} {
      // Only admins can access analytics
      allow read, write: if isAdmin();
    }
    
    // ============================================================================
    // SECURITY: Default deny all other access
    // ============================================================================
    
    match /{document=**} {
      allow read, write: if false;
    }
    
    // Admin OTPs collection
    // Allow authenticated users to create/update OTP for their own email (during login flow)
    // Keep reads restricted to the same email or admins
    match /adminOTPs/{email} {
      allow create: if true;
      allow update: if isAuthenticated() && request.auth.token.email == email;
      allow read: if isAdmin() || (isAuthenticated() && request.auth.token.email == email);
      allow delete: if isAdmin();
    }
    
    match /adminOTPs/{otpId} {
      allow create: if true;

      // Allow UPDATE if:
      // 1. User is authenticated and matches the email (original rule for potential future use cases)
      // OR
      // 2. The update is ONLY changing the 'used' or 'attempts' fields (allowing the verifyOTP function to complete)
      allow update: if (isAuthenticated() && request.auth.token.email == resource.data.email) ||
                       (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['used', 'attempts']));

      // Allow read if user is admin OR authenticated AND their email matches the 'email' field inside the document
      allow read: if isAdmin() || (isAuthenticated() && request.auth.token.email == resource.data.email);

      allow delete: if isAdmin();
    }		

    // Admins collection (optional)
    match /admins/{uid} {
      // Allow admins to read any admin doc; only the owner or an admin can write
      allow read: if isAdmin() || (request.auth != null && request.auth.uid == uid);
      allow write: if request.auth != null && (request.auth.uid == uid || isAdmin());
    }

    // Activity logs (optional)
    match /adminActivity/{docId} {
      allow create: if isAdmin();
      allow read: if isAdmin();
    }
  }
}

